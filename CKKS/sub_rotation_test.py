from math import *
import cmath
import numpy as np
import random
from numpy.polynomial import Polynomial
from RLWE.ring_element import RingElement
import unittest
import sub_rotation as subrot


class TestSubRotation(unittest.TestCase):

    def test_automorphism(self):
        k = 2  # subset size
        i = 1  # number of rotation steps inside subset
        N = 16  # number of slots
        SCALE = 2 ** 9  # rounding scale
        FIVE_POWER_ORDER = N // 2  # order of multiplicative group generated by 5 mod 2N

        zeta = cmath.exp((2j * pi) / (2 * N))
        U, U_conj = subrot.generate_canonical_power_of_five_cosets(2 * N, k)
        slots = [complex(round(random.uniform(-10, 10), 2), round(random.uniform(-10, 10), 2)) for _ in
                                  range(8)]

        # print('slots=              ',slots)
        a = subrot.encode(U, U_conj, 2 * N, slots)
        a_r = [int(x.real * SCALE) for x in a]
        a_elm = RingElement(Polynomial(a_r), 2 * N, mod=10000019)
        # decode_a_elm = subrot.decode(U, U_conj, [x / scale for x in a_elm.poly.coef])
        # print('decode(a_elm/scale)=', [complex(round(x.real, 2), round(x.imag, 2)) for x in decode_a_elm][:n//2])

        power = (5 ** ((FIVE_POWER_ORDER//k)*i) % (2*N))
        eval_a_zeta_power_five = np.polyval(a_elm.poly.coef[::-1], zeta ** power)
        a_k = a_elm.automorphism(power)
        # decode_a_k = subrot.decode(U, U_conj, [x / scale for x in a_k.poly.coef])
        # print('decode(a_k/scale)=  ', [complex(round(x.real, 2), round(x.imag, 2)) for x in decode_a_k][:n//2])
        eval_a_k_zeta = np.polyval(a_k.poly.coef[::-1], zeta)
        #print('eval_a_zeta_power_five: ', eval_a_zeta_power_five)
        self.assertTrue(abs(eval_a_zeta_power_five - eval_a_k_zeta) < 0.001)
