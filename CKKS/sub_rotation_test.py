from math import *
import cmath
import numpy as np
import random
from numpy.polynomial import Polynomial
from RLWE.ring_element import RingElement
import unittest
from sub_rotation import SubRotation


class TestSubRotation(unittest.TestCase):

    def test_automorphism(self):
        i = 1  # number of rotation steps inside subset
        N = 16  # number of slots
        k = 2
        isPrint = False
        SCALE = 2 ** 9  # rounding scale
        FIVE_POWER_ORDER = N // 2  # order of multiplicative group generated by 5 mod 2N

        sub_rotation = SubRotation(2*N, subset_size=k)
        zeta = cmath.exp((2j * pi) / (2 * N))
        slots = [complex(round(random.uniform(-10, 10), 2), round(random.uniform(-10, 10), 2)) for _ in
                                  range(8)]
        a = sub_rotation.encode(slots)
        a_r = [int(x.real * SCALE) for x in a]
        a_elm = RingElement(Polynomial(a_r), 2 * N, mod=10000019)
        power = (5 ** ((FIVE_POWER_ORDER//k)*i) % (2*N))
        eval_a_zeta_power_five = np.polyval(a_elm.poly.coef[::-1], zeta ** power)
        a_k = sub_rotation.rotate(a_elm, i)
        if isPrint:
            print('slots=              ', slots)
            decode_a_elm = sub_rotation.decode([x / SCALE for x in a_elm.poly.coef])
            print('decode(a_elm/scale)=', [complex(round(x.real, 2), round(x.imag, 2)) for x in decode_a_elm][:N // 2])
            decode_a_k = sub_rotation.decode( [x / SCALE for x in a_k.poly.coef])
            print('decode(a_k/scale)=  ', [complex(round(x.real, 2), round(x.imag, 2)) for x in decode_a_k][:N//2])
        eval_a_k_zeta = np.polyval(a_k.poly.coef[::-1], zeta)
        self.assertTrue(abs(eval_a_zeta_power_five - eval_a_k_zeta) < 0.001)

    def test_add(self):
        SCALE = 2 ** 11  # rounding scale
        sub_rotation = SubRotation(dim=32, subset_size=2)

        slots1 = [complex(round(random.uniform(-10, 10), 2), round(random.uniform(-10, 10), 2)) for _ in
                                  range(8)]
        slots2 = [complex(round(random.uniform(-10, 10), 2), round(random.uniform(-10, 10), 2)) for _ in
                  range(8)]

        a1 = sub_rotation.encode(slots1)
        a2 = sub_rotation.encode(slots2)
        a1_elm = RingElement(Polynomial([int(x.real * SCALE) for x in a1]), sub_rotation.dim, mod=10000019)
        a2_elm = RingElement(Polynomial([int(x.real * SCALE) for x in a2]), sub_rotation.dim, mod=10000019)

        a3_elm = a1_elm + a2_elm
        decode_a3 = sub_rotation.decode([x / SCALE for x in a3_elm.poly.coef])[:sub_rotation.dim//4]
        slots3 = []
        for i in range(len(slots1)):
            slots3.append(slots1[i]+slots2[i])
        self.assertTrue(np.allclose(np.array(slots3), np.array(decode_a3), 0.01))

    # def test_mul(self):
    #     mod = 10**9
    #     SCALE = 2 ** 5  # rounding scale
    #     sub_rotation = SubRotation(dim=32, subset_size=2)
    #
    #     slots1 = [complex(round(random.uniform(-10, 10), 2), round(random.uniform(-10, 10), 2)) for _ in
    #                               range(8)]
    #     slots2 = [complex(round(random.uniform(-10, 10), 2), round(random.uniform(-10, 10), 2)) for _ in
    #               range(8)]
    #
    #     a1 = sub_rotation.encode(slots1)
    #     a2 = sub_rotation.encode(slots2)
    #     a1_elm = RingElement(Polynomial([int(x.real * SCALE) for x in a1]), sub_rotation.dim, mod)
    #     a2_elm = RingElement(Polynomial([int(x.real * SCALE) for x in a2]), sub_rotation.dim, mod)
    #     a1_elm = RingElement(Polynomial([1]), sub_rotation.dim, mod)
    #
    #     print('a1_elm=', a1_elm.poly.coef)
    #     print('a2_elm=', a2_elm.poly.coef)
    #     a3_elm = a1_elm * a2_elm
    #     print('a3_elm=', a3_elm.poly.coef)
    #
    #     decode_a3 = sub_rotation.decode([x / SCALE for x in a3_elm.poly.coef])[:sub_rotation.dim//4]
    #     slots3 = []
    #     for i in range(len(slots1)):
    #         slots3.append(slots1[i]*slots2[i])
    #     # print('a1=', a1)
    #     # print('a2=', a2)
    #     print('slots1=', slots1)
    #     print('slots2=', slots2)
    #     print('slots3=', slots3)
    #     print('decode_a3=', decode_a3)
    #     self.assertTrue(np.allclose(np.array(slots3), np.array(decode_a3), 0.001))